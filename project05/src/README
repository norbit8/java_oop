yoav




=============================
=      File description     =
=============================
PACKAGE filters: (In this package I have all the filters I used to filter files, also an Exception class)
    AllFilter.java
    BetweenFilter.java
    ContainsFilter.java
    ExecutableFilter.java
    FileFilter.java
    FilterFactory.java
    Filter.java
    GreaterThanFilter.java
    HiddenFilter.java
    NotFilterDecorator.java
    PrefixFilter.java
    SmallerThanFilter.java
    SuffixFilter.java
    WarningException.java
    WritableFilter.java
PACKAGE filesprocessing: (In this package I have the DirectoryProcessor which is the class with the main)
    DirectoryProcessor.java
PACKAGE manager: (The manager package has the manager class which manages all the program)
    BadSubsectionException.java
    InvalidUsageException.java
    Manager.java
PACKAGE orders: (The orders package has all the orders classes and an Exception class)
    AbsOrder.java
    OrderFactory.java
    Order.java
    ReverseOrderDecorator.java
    SizeOrder.java
    TypeOrder.java
    WarningExceptionOrder.java
PACKAGE parser: (parser package has the parser class and a wrapperFilterOrder class which is "section")
    Parser.java
    WrapperFilterOrder.java
PACKAGE toolbox: (This package has the tool box class which has some usefull functions).
    ToolBox.java
README - this.

=============================
=          Design           =
=============================
In this exercise I used the Design pattern Factory - I created factory of filters and another factory of
orders, both helped me create the desired instance of filter/order I wanted, plus I kept
the single-choice design principle because If I want to change/add some filter/order I can do so
all in one file, which can reduce bugs. (therefor I also kept the open-closed principle because the
program now is open for extensions but closed for modifications).

Another design patter I used is Decorator I used decorator filter and decorator order
to negate the logic of the order and the filter, because the user can ask for some "NOT" filter I can now
just use the regular filter and "Decorate" it with the Not decorator I created, This design pattern
helped me reduce code and added readability.

=============================
=  Implementation details   =
=============================
First I implemented the "Take 2" design suggestion from the "Ex5 - Design Suggestions and Extra Info"
(In the course Moodle).
I implemented each filter in its own class (Open/Closed principle) and created a hierarchy of filters
filters that share a functionality can have a common parent so I created an Interface named "Filter"
where I wrote the abstract function "isPass(file)" which takes a file and return true or false if it
should be filtered or not.
Also I did a similar thing in the Order package where I created an Order abstract class and all the other
orders extends him, in the order abstract class I implemented a sorting algorithm, namly "Quick Sort"
(randomize).
Then In the manager I scanned the command file once to check if its a valid one, and then scanned it again
and for each Filter and Order I generated by the parser a specific filter and order objects,
casted them into a Filter and Order objects, and thanks to the polymorphism mechanism I could use the
specific functionality of each filter and order, in order to print the desired files.
also I used the java's file io library in order to process the command file and the dir with the files.
=============================
=    Answers to questions   =
=============================
